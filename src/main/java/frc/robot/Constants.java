// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot;

/**
 * The Constants class provides a convenient place for teams to hold robot-wide numerical or boolean
 * constants. This class should not be used for any other purpose. All constants should be declared
 * globally (i.e. public static). Do not put anything functional in this class.
 * 
 * do not edit this file unless instructed to do so by Teddy Bullockus!!
 * 
 * <p>It is advised to statically import this class (or one of its inner classes) wherever the
 * constants are needed, to reduce verbosity.
 * @author TomAs 
 */
public final class Constants {

  public static class OperatorConstants {
    public static final int kDriverControllerPort = 0;
  }

  public static class MotorConstants {
    /**
     * Motor type selection for easy switching between motor types
     */
    public enum MotorType {
      KRAKEN,    // Kraken X60 motors
      KRAKEN44,  // Kraken X44 motors (smaller, lower power)
      FALCON     // Falcon 500 motors
    }

    // ===== MOTOR TYPE CONFIGURATION =====
    // Change this to switch between Kraken and Falcon motors
    public static final MotorType kMotorGroup1Type = MotorType.KRAKEN;
    public static final MotorType kMotorGroup2Type = MotorType.KRAKEN;

    // Motor Group 1 - Toggle motors (X button controlled)
    // CAN IDs for TalonFX motor controllers
    public static final int kMotorGroup1Motor1ID = 1;  // Spins clockwise
    public static final int kMotorGroup1Motor2ID = 2;  // Spins counter-clockwise

    // Motor Group 2 - Shooter motors (L1/R1 controlled) - 4 motors total
    public static final int kMotorGroup2Motor1ID = 3;  // Leader
    public static final int kMotorGroup2Motor2ID = 4;  // Follower
    public static final int kMotorGroup2Motor3ID = 6;  // Follower
    public static final int kMotorGroup2Motor4ID = 7;  // Follower

    // CANivore bus name for Motor Group 2
    public static final String kMotorGroup2CANBus = "Default Name";

    // Shooter idle speed - keeps motors spinning for faster spinup
    // This SAVES power by avoiding high-current spinup spikes
    public static final double kShooterIdleRPM = 500.0;  // Minimum RPM when shooter is active
    public static final boolean kUseShooterIdle = true;  // Enable idle speed feature

    // ===== MOTOR GROUP 3 - INTAKE (Kraken X44) =====
    // Square = intake forward, Circle = intake reverse
    public static final MotorType kMotorGroup3Type = MotorType.KRAKEN44;
    public static final int kMotorGroup3MotorID = 5;  // CAN ID for intake motor
    public static final String kMotorGroup3CANBus = "";  // RIO bus (empty = rio)

    // Intake uses BRAKE mode to hold game pieces
    public static final boolean kIntakeUseBrakeMode = true;

    // Intake power (percentage-based for simplicity)
    public static final double kIntakePowerPercent = 75.0;  // 75% power for intake
    public static final double kIntakeReversePowerPercent = 50.0;  // 50% for eject/reverse

    // Kraken X44 current limit (smaller motor than X60)
    public static final double kKraken44CurrentLimit = 40.0;  // Amps - X44 is lower power

    // ===== MOTOR GROUP 4 - INTAKE DEPLOY (Kraken X60) =====
    // D-pad Up = deploy up, D-pad Down = deploy down
    // Uses stall detection to lock position
    public static final MotorType kMotorGroup4Type = MotorType.KRAKEN;
    public static final int kMotorGroup4MotorID = 8;  // CAN ID for deploy motor
    public static final String kMotorGroup4CANBus = "";  // RIO bus

    // Deploy uses BRAKE mode to hold position when stalled
    public static final boolean kDeployUseBrakeMode = true;

    // Deploy power (percentage-based)
    public static final double kDeployDownPowerPercent = 50.0;  // Power to deploy down
    public static final double kDeployUpPowerPercent = 60.0;    // Power to retract up (against gravity)

    // Stall detection - when current spikes and velocity drops, we've hit the stop
    public static final double kDeployStallCurrentThreshold = 35.0;  // Amps - current spike indicates stall
    public static final double kDeployStallVelocityThreshold = 50.0; // RPM - below this = stalled
    public static final double kDeployStallTimeThreshold = 0.1;      // Seconds - duration to confirm stall

    // Deploy position tracking
    public static final double kDeployTotalRotations = 0.33;  // ~120 degrees = 1/3 rotation

    // Motor-specific current limits (Amps)
    // Kraken X60: Higher continuous current capability
    // Falcon 500: Standard current limits
    public static final double kKrakenCurrentLimit = 80.0;  // Amps - Kraken X60 continuous
    public static final double kFalconCurrentLimit = 40.0;  // Amps - Falcon 500 continuous

    // Motor Group 1 cranked current limit to prevent stalling
    public static final double kMotorGroup1CurrentLimitOverride = 120.0;  // Amps - max for anti-stall

    // Get current limit based on motor type
    public static double getMotorGroup1CurrentLimit() {
      return kMotorGroup1CurrentLimitOverride;
    }

    public static double getMotorGroup2CurrentLimit() {
      return kMotorGroup2Type == MotorType.KRAKEN ? kKrakenCurrentLimit : kFalconCurrentLimit;
    }

    // ===== SPEED CONFIGURATION =====
    // Motor Group 1: Percentage-based (0-100%)
    public static final double kMotorGroup1PowerPercent = 5.0;  // Default power % for motor group 1

    // Motor Group 2: RPM-based
    public static final double kMotorGroup2TargetRPM = 100.0;  // Target RPM for motor group 2

    // Convert RPM to rotations per second (native Phoenix 6 units)
    public static final double kMotorGroup2TargetRPS = kMotorGroup2TargetRPM / 60.0;

    // ===== VELOCITY PID CONFIGURATION =====
    // Kraken X60 PID values (low kP - feedforward does the heavy lifting)
    public static final double kKrakenVelocityKp = 0.01;
    public static final double kKrakenVelocityKi = 0.0;
    public static final double kKrakenVelocityKd = 0.0;

    // Falcon 500 PID values (low kP - feedforward does the heavy lifting)
    public static final double kFalconVelocityKp = 0.01;
    public static final double kFalconVelocityKi = 0.0;
    public static final double kFalconVelocityKd = 0.0;

    // ===== FEEDFORWARD CONFIGURATION =====
    // Kraken X60 feedforward (kV calculated from ~6000 RPM free speed)
    // kV = 12V / (free_speed_rps) = 12 / 100 = 0.12
    public static final double kKrakenVelocityKv = 0.12;   // Volts per RPS
    public static final double kKrakenVelocityKs = 0.15;   // Volts to overcome static friction
    public static final double kKrakenVelocityKa = 0.01;   // Volts per RPS/s (acceleration)

    // Falcon 500 feedforward (kV calculated from ~6380 RPM free speed)
    // kV = 12V / (free_speed_rps) = 12 / 106.3 = 0.113
    public static final double kFalconVelocityKv = 0.113;  // Volts per RPS
    public static final double kFalconVelocityKs = 0.15;   // Volts to overcome static friction
    public static final double kFalconVelocityKa = 0.01;   // Volts per RPS/s (acceleration)

    // Get PID and feedforward values based on motor type
    public static double getMotorGroup1Kp() {
      return kMotorGroup1Type == MotorType.KRAKEN ? kKrakenVelocityKp : kFalconVelocityKp;
    }

    public static double getMotorGroup2Kp() {
      return kMotorGroup2Type == MotorType.KRAKEN ? kKrakenVelocityKp : kFalconVelocityKp;
    }

    public static double getMotorGroup1Kv() {
      return kMotorGroup1Type == MotorType.KRAKEN ? kKrakenVelocityKv : kFalconVelocityKv;
    }

    public static double getMotorGroup2Kv() {
      return kMotorGroup2Type == MotorType.KRAKEN ? kKrakenVelocityKv : kFalconVelocityKv;
    }

    public static double getMotorGroup1Ks() {
      return kMotorGroup1Type == MotorType.KRAKEN ? kKrakenVelocityKs : kFalconVelocityKs;
    }

    public static double getMotorGroup2Ks() {
      return kMotorGroup2Type == MotorType.KRAKEN ? kKrakenVelocityKs : kFalconVelocityKs;
    }

    // Get kA feedforward values based on motor type
    public static double getMotorGroup1Ka() {
      return kMotorGroup1Type == MotorType.KRAKEN ? kKrakenVelocityKa : kFalconVelocityKa;
    }

    public static double getMotorGroup2Ka() {
      return kMotorGroup2Type == MotorType.KRAKEN ? kKrakenVelocityKa : kFalconVelocityKa;
    }

    // Ramp rate for smooth acceleration (prevents mechanical stress and belt slipping)
    public static final double kRampRate = 0.25;  // Seconds from 0 to full throttle

    // Brake mode settings - false = coast mode (motors spin freely when stopped)
    public static final boolean kUseBrakeMode = false;

    // ===== MOTOR GROUP 5 - ADJUSTABLE HOOD (Kraken X44 + CANCoder) =====
    // Adjusts shot angle for distance compensation
    public static final MotorType kHoodMotorType = MotorType.KRAKEN44;
    public static final int kHoodMotorID = 17;           // CAN ID for hood motor
    public static final int kHoodEncoderID = 18;         // CAN ID for CANCoder (mag encoder)
    public static final String kHoodCANBus = "";         // RIO bus (empty = rio)

    // Hood uses BRAKE mode to hold position
    public static final boolean kHoodUseBrakeMode = true;

    // Hood position limits (in rotations, calibrated to hardstops)
    // These are encoder positions - calibrate by running to hardstops
    public static final double kHoodRetractedPosition = 0.0;    // Fully retracted (flat shot)
    public static final double kHoodExtendedPosition = 0.25;    // Fully extended (high arc)
    public static final double kHoodDefaultPosition = 0.1;      // Default starting position

    // Hood motion profile - smooth movement to prevent jitter
    public static final double kHoodMaxVelocity = 0.5;          // Rotations per second
    public static final double kHoodMaxAcceleration = 1.0;      // Rotations per second squared
    public static final double kHoodPositionTolerance = 0.005;  // Rotations - ~2 degrees deadband

    // Hood PID gains (position control with Motion Magic)
    public static final double kHoodKp = 50.0;   // Position error gain
    public static final double kHoodKi = 0.0;    // No integral (prevents windup)
    public static final double kHoodKd = 1.0;    // Derivative for damping
    public static final double kHoodKv = 0.12;   // Feedforward velocity
    public static final double kHoodKs = 0.2;    // Static friction compensation
    public static final double kHoodKa = 0.01;   // Acceleration feedforward
    public static final double kHoodKg = 0.1;    // Gravity compensation (hood fights gravity)

    // Hood current limit
    public static final double kHoodCurrentLimit = 30.0;  // Amps - X44 is smaller motor

    // Anti-jitter settings
    public static final double kHoodUpdateDeadband = 0.003;     // Ignore target changes smaller than this
    public static final double kHoodFilterAlpha = 0.1;          // Low-pass filter (0.1 = very smooth)
    public static final int kHoodSettlingCycles = 5;            // Cycles to wait before accepting new target

    // Hood angle to encoder position conversion (for vision)
    // Angle range: 15 degrees (retracted) to 45 degrees (extended)
    public static final double kHoodMinAngleDegrees = 15.0;     // Angle when retracted
    public static final double kHoodMaxAngleDegrees = 45.0;     // Angle when extended

    // Calibration power (slow movement during calibration)
    public static final double kHoodCalibrationPower = 0.15;    // 15% power for calibration
    public static final double kHoodCalibrationStallCurrent = 15.0;  // Amps - stall detection
    public static final double kHoodCalibrationStallVelocity = 5.0;  // RPM - stall detection
  }

  public static class VisionConstants {
    // Camera names - must match the names configured in AprilVision 3.2 UI
    // Set to empty string "" to disable a camera
    public static final String kCamera1Name = "cam1";
    public static final String kCamera2Name = "cam2";
    public static final String kCamera3Name = "cam3";
    public static final String kCamera4Name = "cam4";

    // Camera offsets from robot center (meters and degrees)
    // Tune these in SmartDashboard for accurate measurements
    // X = forward/back, Y = left/right, Z = up/down (meters)
    // Roll, Pitch, Yaw = rotation (degrees)

    // Camera 1 offset (front camera example)
    public static final double kCam1OffsetX = 0.0;
    public static final double kCam1OffsetY = 0.0;
    public static final double kCam1OffsetZ = 0.0;
    public static final double kCam1Roll = 0.0;
    public static final double kCam1Pitch = 0.0;
    public static final double kCam1Yaw = 0.0;

    // Camera 2 offset
    public static final double kCam2OffsetX = 0.0;
    public static final double kCam2OffsetY = 0.0;
    public static final double kCam2OffsetZ = 0.0;
    public static final double kCam2Roll = 0.0;
    public static final double kCam2Pitch = 0.0;
    public static final double kCam2Yaw = 0.0;

    // Camera 3 offset
    public static final double kCam3OffsetX = 0.0;
    public static final double kCam3OffsetY = 0.0;
    public static final double kCam3OffsetZ = 0.0;
    public static final double kCam3Roll = 0.0;
    public static final double kCam3Pitch = 0.0;
    public static final double kCam3Yaw = 0.0;

    // Camera 4 offset
    public static final double kCam4OffsetX = 0.0;
    public static final double kCam4OffsetY = 0.0;
    public static final double kCam4OffsetZ = 0.0;
    public static final double kCam4Roll = 0.0;
    public static final double kCam4Pitch = 0.0;
    public static final double kCam4Yaw = 0.0;

    // 2026 REBUILT Game - HUB AprilTag IDs (all 4 faces of the HUB)
    // Each face has 2 tags: one centered, one offset
    // Red Alliance HUB face tags (offset tags for shooting)
    public static final int[] kRedHubTagIDs = {2, 3, 8, 9};
    // Blue Alliance HUB face tags (offset tags for shooting)
    public static final int[] kBlueHubTagIDs = {18, 19, 24, 25};
    // All HUB tags combined
    public static final int[] kAllHubTagIDs = {2, 3, 4, 5, 8, 9, 10, 11, 18, 19, 20, 21, 24, 25, 26, 27};

    // AprilTag IDs that trigger the shooter (Motor Group 2) - HUB tags
    // Using all HUB tags to trigger autoshoot
    public static final int[] kShooterTriggerTagIDs = {2, 3, 4, 5, 8, 9, 10, 11, 18, 19, 20, 21, 24, 25, 26, 27};

    // AprilTag IDs that trigger the feeder (Motor Group 1) - same as shooter
    // Feeder runs after shooter prespin when seeing HUB
    public static final int[] kFeederTriggerTagIDs = {2, 3, 4, 5, 8, 9, 10, 11, 18, 19, 20, 21, 24, 25, 26, 27};

    // Legacy names for compatibility
    public static final int[] kMotorGroup1TagIDs = kFeederTriggerTagIDs;
    public static final int[] kMotorGroup2TagIDs = kShooterTriggerTagIDs;

    // Minimum number of tags for multi-tag detection (better pose accuracy)
    // With 2 cameras, seeing 2+ tags enables multi-tag pose estimation
    public static final int kMultiTagThreshold = 2;

    // Vision processing update rate (how often to check for tags)
    public static final double kVisionUpdateRateSeconds = 0.02; // 50Hz

    // Area-based speed control for shooter (Motor Group 2)
    // Works without camera calibration! Uses tag area in frame as distance proxy
    // Larger area = closer = less power needed, Smaller area = farther = more power
    public static final double kMaxArea = 8.0;    // % of frame - very close (use min RPM)
    public static final double kMinArea = 0.5;    // % of frame - far away (use max RPM)
    public static final double kMinShooterRPM = 1500.0;    // RPM when close (large area)
    public static final double kMaxShooterRPM = 4000.0;    // RPM when far (small area)

    // Prespin delay - time Motor Group 2 runs before Motor Group 1 starts
    public static final double kPrespinDelaySeconds = 1.0;  // 1 second prespin time

    // ===== SPEED PROFILES =====
    // Line Drive - fast, flat trajectory (default)
    public static final double kLineDriveMinRPM = 1500.0;
    public static final double kLineDriveMaxRPM = 4000.0;

    // Lob Shot - slower, higher arc trajectory
    public static final double kLobShotMinRPM = 800.0;
    public static final double kLobShotMaxRPM = 2500.0;

    // ===== ALIGNMENT THRESHOLDS =====
    // Yaw (horizontal) alignment - degrees from center
    public static final double kAlignedYawThreshold = 3.0;      // Within 3° = perfectly aligned
    public static final double kCloseYawThreshold = 8.0;        // Within 8° = close to aligned

    // ===== SHOT COUNTER =====
    public static final int kMaxShotsPerSession = 50;           // Max shots before warning (0 = unlimited)
    public static final double kShotDetectionRPMThreshold = 500.0;  // Min RPM to count as "shooting"

    // ===== TARGET LOCK FEEDBACK =====
    public static final double kRumbleIntensity = 0.5;          // 0.0 to 1.0
    public static final double kRumbleDuration = 0.2;           // Seconds per rumble pulse

    // ===== BEST TAG SELECTION =====
    public static final double kMaxAmbiguityThreshold = 0.15;   // Tags with higher ambiguity are lower priority
  }

  public static class TelemetryConstants {
    // ===== PIGEON 2 IMU =====
    // Set to -1 to disable Pigeon 2 / odometry
    public static final int kPigeon2ID = 0;  // CAN ID of Pigeon 2 (0 = default, -1 = disabled)
    public static final String kPigeon2CANBus = "";  // Empty = rio bus, or CANivore name

    // ===== TELEMETRY UPDATE RATES =====
    // Lower = less CPU usage, higher = more data resolution
    public static final double kTelemetryUpdateHz = 50.0;  // Main telemetry loop (50Hz)
    public static final double kOdometryUpdateHz = 100.0;  // Odometry updates (100Hz for accuracy)
    public static final double kSlowTelemetryHz = 10.0;    // Slow metrics (battery, temps) at 10Hz

    // ===== FIELD DIMENSIONS (2026 REBUILT) =====
    // Field is 54'1" x 26'7" (standard FRC field)
    public static final double kFieldLengthMeters = 16.4846;  // 54'1" in meters
    public static final double kFieldWidthMeters = 8.1026;    // 26'7" in meters

    // ===== ROBOT STARTING POSITION =====
    // Default starting position (can be overridden via dashboard)
    public static final double kDefaultStartX = 1.0;  // meters from field origin
    public static final double kDefaultStartY = 4.0;  // meters from field origin
    public static final double kDefaultStartHeadingDeg = 0.0;  // degrees

    // ===== NETWORKTABLES PATHS =====
    // All telemetry data published under this root
    public static final String kTelemetryTableName = "Telemetry";
    public static final String kOdometryTableName = "Telemetry/Odometry";
    public static final String kMotorsTableName = "Telemetry/Motors";
    public static final String kVisionTelemetryTableName = "Telemetry/Vision";
    public static final String kSystemTableName = "Telemetry/System";
    public static final String kEventsTableName = "Telemetry/Events";
    public static final String kMatchTableName = "Telemetry/Match";

    // ===== DATA COLLECTION FLAGS =====
    public static final boolean kLogMotorData = true;
    public static final boolean kLogVisionData = true;
    public static final boolean kLogSystemHealth = true;
    public static final boolean kLogControllerInputs = true;
    public static final boolean kLogMatchEvents = true;

    // ===== MOTOR AUTO-DISCOVERY =====
    // Set to false to disable CAN scanning (uses kExpectedMotorIDs only)
    public static final boolean kEnableMotorDiscovery = true;
    // Expected motor CAN IDs - only these are checked (fast startup)
    public static final int[] kExpectedMotorIDs = {1, 2, 3, 4, 5, 6, 7, 8};  // All motors including deploy
    // CAN buses to scan (empty string = RIO bus)
    public static final String[] kCANBusNames = {"", "Default Name"};
  }

  public static class PowerConstants {
    // ===== VOLTAGE THRESHOLDS =====
    // These define when power management activates
    // CRITICAL: Only intervene at very low voltages to not affect feel
    public static final double kNominalVoltage = 12.5;      // Fresh battery
    public static final double kWarningVoltage = 11.5;      // Warning only, no action
    public static final double kCriticalVoltage = 11.0;     // Brownout risk - mild conservation
    public static final double kEmergencyVoltage = 10.5;    // Imminent brownout - aggressive save

    // ===== BROWNOUT PREDICTION =====
    // Voltage slope thresholds (V/s) - negative = dropping
    public static final double kNormalSlopeThreshold = -0.1;    // Normal discharge
    public static final double kRapidSlopeThreshold = -0.3;     // Heavy load, watch carefully
    public static final double kCriticalSlopeThreshold = -0.5;  // Brownout likely soon

    // Prediction window (seconds to look ahead)
    public static final double kBrownoutPredictionWindowSec = 0.5;

    // ===== THERMAL THRESHOLDS =====
    public static final double kMotorTempWarning = 60.0;    // °C - log warning
    public static final double kMotorTempCritical = 70.0;   // °C - consider throttle
    public static final double kMotorTempShutdown = 80.0;   // °C - must stop motor

    // ===== CURRENT MONITORING =====
    // Total robot current estimation (for power budget)
    public static final double kMaxSafeCurrentDraw = 120.0;  // Amps total
    public static final double kHighCurrentWarning = 100.0;  // Amps - warning level

    // ===== POWER MODE SCALING =====
    // Only applied in CRITICAL/EMERGENCY modes
    // 1.0 = full power, 0.0 = no power
    public static final double kCriticalModeShooterScale = 1.0;   // Shooter always full power
    public static final double kCriticalModeFeederScale = 1.0;    // Feeder always full power
    public static final double kCriticalModeIntakeScale = 0.8;    // Intake can be reduced slightly
    public static final double kEmergencyModeIntakeScale = 0.6;   // Further reduce in emergency

    // ===== UPDATE RATE =====
    public static final double kPowerMonitorHz = 50.0;  // Match main loop
  }

  public static class SwerveConstants {
    // ===== SWERVE DRIVE MODULE MOTORS =====
    // 4 modules: Front Left (FL), Front Right (FR), Back Left (BL), Back Right (BR)
    // Each module has: 1 Kraken X44 (steering) + 1 Kraken X60 (drive)

    // CANivore bus name for all swerve modules
    public static final String kSwerveCANBus = "Default Name";

    // ===== STEERING MOTORS (Kraken X44) =====
    // Kraken X44 - smaller, lower power motors for azimuth/steering
    public static final int kFrontLeftSteerMotorID = 9;    // FL steering
    public static final int kFrontRightSteerMotorID = 10;  // FR steering
    public static final int kBackLeftSteerMotorID = 11;    // BL steering
    public static final int kBackRightSteerMotorID = 12;   // BR steering

    // ===== DRIVE MOTORS (Kraken X60) =====
    // Kraken X60 - full power motors for driving
    public static final int kFrontLeftDriveMotorID = 13;   // FL drive
    public static final int kFrontRightDriveMotorID = 14;  // FR drive
    public static final int kBackLeftDriveMotorID = 15;    // BL drive
    public static final int kBackRightDriveMotorID = 16;   // BR drive
  }
}
//smooth accel code 