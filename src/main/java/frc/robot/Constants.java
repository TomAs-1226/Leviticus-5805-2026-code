// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot;

/**
 * The Constants class provides a convenient place for teams to hold robot-wide numerical or boolean
 * constants. This class should not be used for any other purpose. All constants should be declared
 * globally (i.e. public static). Do not put anything functional in this class.
 * 
 * do not edit this file unless instructed to do so by Teddy Bullockus!!
 * 
 * <p>It is advised to statically import this class (or one of its inner classes) wherever the
 * constants are needed, to reduce verbosity.
 * @author TomAs 
 */
public final class Constants {

  public static class OperatorConstants {
    public static final int kDriverControllerPort = 0;
  }

  public static class MotorConstants {
    /**
     * Motor type selection for easy switching between motor types
     */
    public enum MotorType {
      KRAKEN,    // Kraken X60 motors
      KRAKEN44,  // Kraken X44 motors (smaller, lower power)
      FALCON     // Falcon 500 motors
    }

    // ===== MOTOR TYPE CONFIGURATION =====
    // Change this to switch between Kraken and Falcon motors
    public static final MotorType kMotorGroup1Type = MotorType.KRAKEN;
    public static final MotorType kMotorGroup2Type = MotorType.KRAKEN;

    // Motor Group 1 - Toggle motors (X button controlled)
    // CAN IDs for TalonFX motor controllers
    public static final int kMotorGroup1Motor1ID = 1;  // Spins clockwise
    public static final int kMotorGroup1Motor2ID = 2;  // Spins counter-clockwise

    // Motor Group 2 - Shooter motors (L1/R1 controlled) - 4 motors total
    public static final int kMotorGroup2Motor1ID = 3;  // Leader
    public static final int kMotorGroup2Motor2ID = 4;  // Follower
    public static final int kMotorGroup2Motor3ID = 6;  // Follower
    public static final int kMotorGroup2Motor4ID = 7;  // Follower

    // CANivore bus name for Motor Group 2
    public static final String kMotorGroup2CANBus = "Default Name";

    // Shooter idle speed - keeps motors spinning for faster spinup
    // This SAVES power by avoiding high-current spinup spikes
    public static final double kShooterIdleRPM = 500.0;  // Minimum RPM when shooter is active
    public static final boolean kUseShooterIdle = true;  // Enable idle speed feature

    // ===== MOTOR GROUP 3 - INTAKE (Kraken X44) =====
    // Square = intake forward, Circle = intake reverse
    public static final MotorType kMotorGroup3Type = MotorType.KRAKEN44;
    public static final int kMotorGroup3MotorID = 5;  // CAN ID for intake motor
    public static final String kMotorGroup3CANBus = "";  // RIO bus (empty = rio)

    // Intake uses BRAKE mode to hold game pieces
    public static final boolean kIntakeUseBrakeMode = true;

    // Intake power (percentage-based for simplicity)
    public static final double kIntakePowerPercent = 75.0;  // 75% power for intake
    public static final double kIntakeReversePowerPercent = 50.0;  // 50% for eject/reverse

    // Kraken X44 current limit (smaller motor than X60)
    public static final double kKraken44CurrentLimit = 40.0;  // Amps - X44 is lower power

    // ===== MOTOR GROUP 4 - INTAKE DEPLOY (Kraken X60) =====
    // D-pad Up = deploy up, D-pad Down = deploy down
    // Uses stall detection to lock position
    public static final MotorType kMotorGroup4Type = MotorType.KRAKEN;
    public static final int kMotorGroup4MotorID = 8;  // CAN ID for deploy motor
    public static final String kMotorGroup4CANBus = "";  // RIO bus

    // Deploy uses BRAKE mode to hold position when stalled
    public static final boolean kDeployUseBrakeMode = true;

    // Deploy power (percentage-based)
    public static final double kDeployDownPowerPercent = 50.0;  // Power to deploy down
    public static final double kDeployUpPowerPercent = 60.0;    // Power to retract up (against gravity)

    // Stall detection - when current spikes and velocity drops, we've hit the stop
    public static final double kDeployStallCurrentThreshold = 35.0;  // Amps - current spike indicates stall
    public static final double kDeployStallVelocityThreshold = 50.0; // RPM - below this = stalled
    public static final double kDeployStallTimeThreshold = 0.1;      // Seconds - duration to confirm stall

    // Deploy position tracking
    public static final double kDeployTotalRotations = 0.33;  // ~120 degrees = 1/3 rotation

    // Motor-specific current limits (Amps)
    // Kraken X60: Higher continuous current capability
    // Falcon 500: Standard current limits
    public static final double kKrakenCurrentLimit = 80.0;  // Amps - Kraken X60 continuous
    public static final double kFalconCurrentLimit = 40.0;  // Amps - Falcon 500 continuous

    // Motor Group 1 cranked current limit to prevent stalling
    public static final double kMotorGroup1CurrentLimitOverride = 120.0;  // Amps - max for anti-stall

    // Get current limit based on motor type
    public static double getMotorGroup1CurrentLimit() {
      return kMotorGroup1CurrentLimitOverride;
    }

    public static double getMotorGroup2CurrentLimit() {
      return kMotorGroup2Type == MotorType.KRAKEN ? kKrakenCurrentLimit : kFalconCurrentLimit;
    }

    // ===== SPEED CONFIGURATION =====
    // Motor Group 1: Percentage-based (0-100%)
    public static final double kMotorGroup1PowerPercent = 5.0;  // Default power % for motor group 1

    // Motor Group 2: RPM-based
    public static final double kMotorGroup2TargetRPM = 100.0;  // Target RPM for motor group 2

    // Convert RPM to rotations per second (native Phoenix 6 units)
    public static final double kMotorGroup2TargetRPS = kMotorGroup2TargetRPM / 60.0;

    // ===== VELOCITY PID CONFIGURATION =====
    // Kraken X60 PID values (low kP - feedforward does the heavy lifting)
    public static final double kKrakenVelocityKp = 0.01;
    public static final double kKrakenVelocityKi = 0.0;
    public static final double kKrakenVelocityKd = 0.0;

    // Falcon 500 PID values (low kP - feedforward does the heavy lifting)
    public static final double kFalconVelocityKp = 0.01;
    public static final double kFalconVelocityKi = 0.0;
    public static final double kFalconVelocityKd = 0.0;

    // ===== FEEDFORWARD CONFIGURATION =====
    // Kraken X60 feedforward (kV calculated from ~6000 RPM free speed)
    // kV = 12V / (free_speed_rps) = 12 / 100 = 0.12
    public static final double kKrakenVelocityKv = 0.12;   // Volts per RPS
    public static final double kKrakenVelocityKs = 0.15;   // Volts to overcome static friction
    public static final double kKrakenVelocityKa = 0.01;   // Volts per RPS/s (acceleration)

    // Falcon 500 feedforward (kV calculated from ~6380 RPM free speed)
    // kV = 12V / (free_speed_rps) = 12 / 106.3 = 0.113
    public static final double kFalconVelocityKv = 0.113;  // Volts per RPS
    public static final double kFalconVelocityKs = 0.15;   // Volts to overcome static friction
    public static final double kFalconVelocityKa = 0.01;   // Volts per RPS/s (acceleration)

    // Get PID and feedforward values based on motor type
    public static double getMotorGroup1Kp() {
      return kMotorGroup1Type == MotorType.KRAKEN ? kKrakenVelocityKp : kFalconVelocityKp;
    }

    public static double getMotorGroup2Kp() {
      return kMotorGroup2Type == MotorType.KRAKEN ? kKrakenVelocityKp : kFalconVelocityKp;
    }

    public static double getMotorGroup1Kv() {
      return kMotorGroup1Type == MotorType.KRAKEN ? kKrakenVelocityKv : kFalconVelocityKv;
    }

    public static double getMotorGroup2Kv() {
      return kMotorGroup2Type == MotorType.KRAKEN ? kKrakenVelocityKv : kFalconVelocityKv;
    }

    public static double getMotorGroup1Ks() {
      return kMotorGroup1Type == MotorType.KRAKEN ? kKrakenVelocityKs : kFalconVelocityKs;
    }

    public static double getMotorGroup2Ks() {
      return kMotorGroup2Type == MotorType.KRAKEN ? kKrakenVelocityKs : kFalconVelocityKs;
    }

    // Get kA feedforward values based on motor type
    public static double getMotorGroup1Ka() {
      return kMotorGroup1Type == MotorType.KRAKEN ? kKrakenVelocityKa : kFalconVelocityKa;
    }

    public static double getMotorGroup2Ka() {
      return kMotorGroup2Type == MotorType.KRAKEN ? kKrakenVelocityKa : kFalconVelocityKa;
    }

    // Ramp rate for smooth acceleration (prevents mechanical stress and belt slipping)
    public static final double kRampRate = 0.25;  // Seconds from 0 to full throttle

    // Brake mode settings - false = coast mode (motors spin freely when stopped)
    public static final boolean kUseBrakeMode = false;

    // ===== MOTOR GROUP 5 - ADJUSTABLE HOOD (Kraken X44 + CANCoder) =====
    // Adjusts shot angle for distance compensation
    public static final MotorType kHoodMotorType = MotorType.KRAKEN44;
    public static final int kHoodMotorID = 17;           // CAN ID for hood motor
    public static final int kHoodEncoderID = 18;         // CAN ID for CANCoder (mag encoder)
    public static final String kHoodCANBus = "";         // RIO bus (empty = rio)

    // Hood uses BRAKE mode to hold position
    public static final boolean kHoodUseBrakeMode = true;

    // Hood position limits (in rotations, calibrated to hardstops)
    // These are encoder positions - calibrate by running to hardstops
    public static final double kHoodRetractedPosition = 0.0;    // Fully retracted (flat shot)
    public static final double kHoodExtendedPosition = 0.25;    // Fully extended (high arc)
    public static final double kHoodDefaultPosition = 0.1;      // Default starting position

    // Hood motion profile - smooth movement to prevent jitter
    public static final double kHoodMaxVelocity = 0.5;          // Rotations per second
    public static final double kHoodMaxAcceleration = 1.0;      // Rotations per second squared
    public static final double kHoodPositionTolerance = 0.005;  // Rotations - ~2 degrees deadband

    // Hood PID gains (position control with Motion Magic)
    public static final double kHoodKp = 50.0;   // Position error gain
    public static final double kHoodKi = 0.0;    // No integral (prevents windup)
    public static final double kHoodKd = 1.0;    // Derivative for damping
    public static final double kHoodKv = 0.12;   // Feedforward velocity
    public static final double kHoodKs = 0.2;    // Static friction compensation
    public static final double kHoodKa = 0.01;   // Acceleration feedforward
    public static final double kHoodKg = 0.1;    // Gravity compensation (hood fights gravity)

    // Hood current limit
    public static final double kHoodCurrentLimit = 30.0;  // Amps - X44 is smaller motor

    // Anti-jitter settings
    public static final double kHoodUpdateDeadband = 0.003;     // Ignore target changes smaller than this
    public static final double kHoodFilterAlpha = 0.1;          // Low-pass filter (0.1 = very smooth)
    public static final int kHoodSettlingCycles = 5;            // Cycles to wait before accepting new target

    // Hood angle to encoder position conversion (for vision)
    // Angle range: 15 degrees (retracted) to 45 degrees (extended)
    public static final double kHoodMinAngleDegrees = 15.0;     // Angle when retracted
    public static final double kHoodMaxAngleDegrees = 45.0;     // Angle when extended

    // Calibration power (slow movement during calibration)
    public static final double kHoodCalibrationPower = 0.15;    // 15% power for calibration
    public static final double kHoodCalibrationStallCurrent = 15.0;  // Amps - stall detection
    public static final double kHoodCalibrationStallVelocity = 5.0;  // RPM - stall detection
  }

  public static class VisionConstants {
    // ===== CAMERA HARDWARE CONFIGURATION =====
    // 4 ArduCam setup: 2 mono (AprilTag), 2 color (game piece)
    // Camera names must match PhotonVision/AprilVision UI configuration

    // Camera type enum for processing mode selection
    public enum CameraType {
      MONO,   // Grayscale - faster AprilTag processing
      COLOR   // RGB - game piece detection
    }

    // ===== MONO CAMERAS (AprilTag Localization) =====
    // Mounted at diagonal corners for 360° AprilTag coverage
    // ArduCam OV9281 Global Shutter Mono recommended for AprilTags
    public static final String kMonoCam1Name = "mono_fl";  // Front-Left corner
    public static final String kMonoCam2Name = "mono_br";  // Back-Right corner
    public static final CameraType kMonoCam1Type = CameraType.MONO;
    public static final CameraType kMonoCam2Type = CameraType.MONO;

    // ===== COLOR CAMERAS (Game Piece Detection) =====
    // Front for intake targeting, Back for field awareness
    // ArduCam OV9782 Color recommended for game pieces
    public static final String kColorCam1Name = "color_front";  // Front center
    public static final String kColorCam2Name = "color_back";   // Rear center
    public static final CameraType kColorCam1Type = CameraType.COLOR;
    public static final CameraType kColorCam2Type = CameraType.COLOR;

    // Legacy camera name aliases for compatibility
    public static final String kCamera1Name = kMonoCam1Name;
    public static final String kCamera2Name = kMonoCam2Name;
    public static final String kCamera3Name = kColorCam1Name;
    public static final String kCamera4Name = kColorCam2Name;

    // ===== ARDUCAM SETTINGS =====
    // Resolution settings (higher = better accuracy, lower = faster processing)
    public static final int kMonoCamResWidth = 1280;   // OV9281 native
    public static final int kMonoCamResHeight = 800;
    public static final int kColorCamResWidth = 1280;  // OV9782 native
    public static final int kColorCamResHeight = 800;

    // Exposure settings (lower = less motion blur, requires good lighting)
    public static final int kMonoCamExposureMs = 5;    // Fast exposure for tags
    public static final int kColorCamExposureMs = 10;  // Slightly longer for color

    // ===== CAMERA MOUNTING POSITIONS =====
    // Measured from robot center (meters and degrees)
    // X = forward(+)/back(-), Y = left(+)/right(-), Z = up from floor
    // Pitch = tilt down(+)/up(-), Yaw = rotate left(+)/right(-)
    // IMPORTANT: Don't mount at AprilTag height (0.57m) - angle cameras!

    // Mono Cam 1 - Front-Left corner, angled outward
    // TUNE THESE VALUES - measure from robot center to camera lens
    public static final double kMonoCam1X = 0.0;       // Forward offset (meters)
    public static final double kMonoCam1Y = 0.0;       // Left offset (meters)
    public static final double kMonoCam1Z = 0.0;       // Height from floor (meters)
    public static final double kMonoCam1Roll = 0.0;    // Roll (degrees)
    public static final double kMonoCam1Pitch = 0.0;   // Tilt down 15° to see tags (degrees)
    public static final double kMonoCam1Yaw = 0.0;     // Angled 45° left (degrees)

    // Mono Cam 2 - Back-Right corner, angled outward
    public static final double kMonoCam2X = 0.0;       // Backward offset
    public static final double kMonoCam2Y = 0.0;       // Right offset
    public static final double kMonoCam2Z = 0.0;
    public static final double kMonoCam2Roll = 0.0;
    public static final double kMonoCam2Pitch = 0.0;   // Tilt down
    public static final double kMonoCam2Yaw = 0.0;     // Angled 45° right (180+45=225 or -135)

    // Color Cam 1 - Front center, forward-facing
    public static final double kColorCam1X = 0.0;      // Front of robot
    public static final double kColorCam1Y = 0.0;      // Centered
    public static final double kColorCam1Z = 0.0;
    public static final double kColorCam1Roll = 0.0;
    public static final double kColorCam1Pitch = 0.0;  // Slight tilt for floor game pieces
    public static final double kColorCam1Yaw = 0.0;    // Straight forward

    // Color Cam 2 - Back center, rear-facing
    public static final double kColorCam2X = 0.0;      // Back of robot
    public static final double kColorCam2Y = 0.0;      // Centered
    public static final double kColorCam2Z = 0.0;
    public static final double kColorCam2Roll = 0.0;
    public static final double kColorCam2Pitch = 0.0;
    public static final double kColorCam2Yaw = 180.0;  // Facing backward

    // Legacy offset aliases for compatibility
    public static final double kCam1OffsetX = kMonoCam1X;
    public static final double kCam1OffsetY = kMonoCam1Y;
    public static final double kCam1OffsetZ = kMonoCam1Z;
    public static final double kCam1Roll = kMonoCam1Roll;
    public static final double kCam1Pitch = kMonoCam1Pitch;
    public static final double kCam1Yaw = kMonoCam1Yaw;
    public static final double kCam2OffsetX = kMonoCam2X;
    public static final double kCam2OffsetY = kMonoCam2Y;
    public static final double kCam2OffsetZ = kMonoCam2Z;
    public static final double kCam2Roll = kMonoCam2Roll;
    public static final double kCam2Pitch = kMonoCam2Pitch;
    public static final double kCam2Yaw = kMonoCam2Yaw;
    public static final double kCam3OffsetX = kColorCam1X;
    public static final double kCam3OffsetY = kColorCam1Y;
    public static final double kCam3OffsetZ = kColorCam1Z;
    public static final double kCam3Roll = kColorCam1Roll;
    public static final double kCam3Pitch = kColorCam1Pitch;
    public static final double kCam3Yaw = kColorCam1Yaw;
    public static final double kCam4OffsetX = kColorCam2X;
    public static final double kCam4OffsetY = kColorCam2Y;
    public static final double kCam4OffsetZ = kColorCam2Z;
    public static final double kCam4Roll = kColorCam2Roll;
    public static final double kCam4Pitch = kColorCam2Pitch;
    public static final double kCam4Yaw = kColorCam2Yaw;

    // 2026 REBUILT Game - HUB AprilTag IDs (all 4 faces of the HUB)
    // Each face has 2 tags: one centered, one offset
    // Red Alliance HUB face tags (offset tags for shooting)
    public static final int[] kRedHubTagIDs = {2, 3, 8, 9};
    // Blue Alliance HUB face tags (offset tags for shooting)
    public static final int[] kBlueHubTagIDs = {18, 19, 24, 25};
    // All HUB tags combined
    public static final int[] kAllHubTagIDs = {2, 3, 4, 5, 8, 9, 10, 11, 18, 19, 20, 21, 24, 25, 26, 27};

    // AprilTag IDs that trigger the shooter (Motor Group 2) - HUB tags
    // Using all HUB tags to trigger autoshoot
    public static final int[] kShooterTriggerTagIDs = {2, 3, 4, 5, 8, 9, 10, 11, 18, 19, 20, 21, 24, 25, 26, 27};

    // AprilTag IDs that trigger the feeder (Motor Group 1) - same as shooter
    // Feeder runs after shooter prespin when seeing HUB
    public static final int[] kFeederTriggerTagIDs = {2, 3, 4, 5, 8, 9, 10, 11, 18, 19, 20, 21, 24, 25, 26, 27};

    // Legacy names for compatibility
    public static final int[] kMotorGroup1TagIDs = kFeederTriggerTagIDs;
    public static final int[] kMotorGroup2TagIDs = kShooterTriggerTagIDs;

    // Minimum number of tags for multi-tag detection (better pose accuracy)
    // With 2 cameras, seeing 2+ tags enables multi-tag pose estimation
    public static final int kMultiTagThreshold = 2;

    // Vision processing update rate (how often to check for tags)
    public static final double kVisionUpdateRateSeconds = 0.02; // 50Hz

    // Area-based speed control for shooter (Motor Group 2)
    // Works without camera calibration! Uses tag area in frame as distance proxy
    // Larger area = closer = less power needed, Smaller area = farther = more power
    public static final double kMaxArea = 8.0;    // % of frame - very close (use min RPM)
    public static final double kMinArea = 0.5;    // % of frame - far away (use max RPM)
    public static final double kMinShooterRPM = 1500.0;    // RPM when close (large area)
    public static final double kMaxShooterRPM = 4000.0;    // RPM when far (small area)

    // Prespin delay - time Motor Group 2 runs before Motor Group 1 starts
    public static final double kPrespinDelaySeconds = 1.0;  // 1 second prespin time

    // ===== SPEED PROFILES =====
    // Line Drive - fast, flat trajectory (default)
    public static final double kLineDriveMinRPM = 1500.0;
    public static final double kLineDriveMaxRPM = 4000.0;

    // Lob Shot - slower, higher arc trajectory
    public static final double kLobShotMinRPM = 800.0;
    public static final double kLobShotMaxRPM = 2500.0;

    // ===== ALIGNMENT THRESHOLDS =====
    // Yaw (horizontal) alignment - degrees from center
    public static final double kAlignedYawThreshold = 3.0;      // Within 3° = perfectly aligned
    public static final double kCloseYawThreshold = 8.0;        // Within 8° = close to aligned

    // ===== SHOT COUNTER =====
    public static final int kMaxShotsPerSession = 50;           // Max shots before warning (0 = unlimited)
    public static final double kShotDetectionRPMThreshold = 500.0;  // Min RPM to count as "shooting"

    // ===== TARGET LOCK FEEDBACK =====
    public static final double kRumbleIntensity = 0.5;          // 0.0 to 1.0
    public static final double kRumbleDuration = 0.2;           // Seconds per rumble pulse

    // ===== BEST TAG SELECTION =====
    public static final double kMaxAmbiguityThreshold = 0.15;   // Tags with higher ambiguity are lower priority

    // ===== TAG MEMORY SYSTEM =====
    // Context-aware tag retention when tag briefly disappears
    public static final double kTagHoldTimeShooting = 0.25;     // 250ms when actively shooting
    public static final double kTagHoldTimeSpinup = 0.15;       // 150ms during spinup
    public static final double kTagHoldTimeIdle = 0.10;         // 100ms when idle
    public static final double kCooldownDuration = 0.3;         // Time in cooldown state after shooting

    // ===== PREDICTIVE TRACKING =====
    public static final double kPredictiveConfidenceThreshold = 0.7;  // Min confidence to use prediction
    public static final double kMinDistanceThreshold = 0.01;          // Min distance to use distance-based RPM

    // ===== SHOOTER VELOCITY VERIFICATION =====
    // Verify shooter is at speed before feeding to prevent jams
    public static final double kShooterRPMTolerance = 0.85;           // 85% of target RPM required
    public static final boolean kRequireShooterAtSpeed = true;        // Enable velocity check before feeding
  }

  public static class TelemetryConstants {
    // ===== PIGEON 2 IMU =====
    // Set to -1 to disable Pigeon 2 / odometry
    public static final int kPigeon2ID = 0;  // CAN ID of Pigeon 2 (0 = default, -1 = disabled)
    public static final String kPigeon2CANBus = "";  // Empty = rio bus, or CANivore name

    // ===== TELEMETRY UPDATE RATES =====
    // Lower = less CPU usage, higher = more data resolution
    public static final double kTelemetryUpdateHz = 50.0;  // Main telemetry loop (50Hz)
    public static final double kOdometryUpdateHz = 100.0;  // Odometry updates (100Hz for accuracy)
    public static final double kSlowTelemetryHz = 10.0;    // Slow metrics (battery, temps) at 10Hz

    // ===== FIELD DIMENSIONS (2026 REBUILT) =====
    // Field is 54'1" x 26'7" (standard FRC field)
    public static final double kFieldLengthMeters = 16.4846;  // 54'1" in meters
    public static final double kFieldWidthMeters = 8.1026;    // 26'7" in meters

    // ===== ROBOT STARTING POSITION =====
    // Default starting position (can be overridden via dashboard)
    public static final double kDefaultStartX = 1.0;  // meters from field origin
    public static final double kDefaultStartY = 4.0;  // meters from field origin
    public static final double kDefaultStartHeadingDeg = 0.0;  // degrees

    // ===== NETWORKTABLES PATHS =====
    // All telemetry data published under this root
    public static final String kTelemetryTableName = "Telemetry";
    public static final String kOdometryTableName = "Telemetry/Odometry";
    public static final String kMotorsTableName = "Telemetry/Motors";
    public static final String kVisionTelemetryTableName = "Telemetry/Vision";
    public static final String kSystemTableName = "Telemetry/System";
    public static final String kEventsTableName = "Telemetry/Events";
    public static final String kMatchTableName = "Telemetry/Match";

    // ===== DATA COLLECTION FLAGS =====
    public static final boolean kLogMotorData = true;
    public static final boolean kLogVisionData = true;
    public static final boolean kLogSystemHealth = true;
    public static final boolean kLogControllerInputs = true;
    public static final boolean kLogMatchEvents = true;

    // ===== MOTOR AUTO-DISCOVERY =====
    // Set to false to disable CAN scanning (uses kExpectedMotorIDs only)
    public static final boolean kEnableMotorDiscovery = true;
    // Expected motor CAN IDs - only these are checked (fast startup)
    // IDs 1-8: Mechanism motors (feeder, shooter, intake, deploy, hood)
    // IDs 9-16: Swerve motors (steer 9-12, drive 13-16)
    // ID 17: Hood motor, ID 18: Hood CANCoder
    public static final int[] kExpectedMotorIDs = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};
    // CAN buses to scan (empty string = RIO bus)
    public static final String[] kCANBusNames = {"", "Default Name"};
  }

  public static class PowerConstants {
    // ===== VOLTAGE THRESHOLDS =====
    // These define when power management activates
    // CRITICAL: Only intervene at very low voltages to not affect feel
    public static final double kNominalVoltage = 12.5;      // Fresh battery
    public static final double kWarningVoltage = 11.5;      // Warning only, no action
    public static final double kCriticalVoltage = 11.0;     // Brownout risk - mild conservation
    public static final double kEmergencyVoltage = 10.5;    // Imminent brownout - aggressive save

    // ===== BROWNOUT PREDICTION =====
    // Voltage slope thresholds (V/s) - negative = dropping
    public static final double kNormalSlopeThreshold = -0.1;    // Normal discharge
    public static final double kRapidSlopeThreshold = -0.3;     // Heavy load, watch carefully
    public static final double kCriticalSlopeThreshold = -0.5;  // Brownout likely soon

    // Prediction window (seconds to look ahead)
    public static final double kBrownoutPredictionWindowSec = 0.5;

    // ===== THERMAL THRESHOLDS =====
    public static final double kMotorTempWarning = 60.0;    // °C - log warning
    public static final double kMotorTempCritical = 70.0;   // °C - consider throttle
    public static final double kMotorTempShutdown = 80.0;   // °C - must stop motor

    // ===== CURRENT MONITORING =====
    // Total robot current estimation (for power budget)
    public static final double kMaxSafeCurrentDraw = 120.0;  // Amps total
    public static final double kHighCurrentWarning = 100.0;  // Amps - warning level

    // ===== POWER MODE SCALING =====
    // Only applied in CRITICAL/EMERGENCY modes
    // 1.0 = full power, 0.0 = no power
    public static final double kCriticalModeShooterScale = 1.0;   // Shooter always full power
    public static final double kCriticalModeFeederScale = 1.0;    // Feeder always full power
    public static final double kCriticalModeIntakeScale = 0.8;    // Intake can be reduced slightly
    public static final double kEmergencyModeIntakeScale = 0.6;   // Further reduce in emergency

    // ===== UPDATE RATE =====
    public static final double kPowerMonitorHz = 50.0;  // Match main loop
  }

  public static class SwerveConstants {
    // ===== SWERVE DRIVE MODULE MOTORS =====
    // 4 modules: Front Left (FL), Front Right (FR), Back Left (BL), Back Right (BR)
    // Each module has: 1 Kraken X44 (steering) + 1 Kraken X60 (drive) + 1 CANCoder

    // CANivore bus name for all swerve modules
    public static final String kSwerveCANBus = "Default Name";

    // ===== STEERING MOTORS (Kraken X44) =====
    // Kraken X44 - smaller, lower power motors for azimuth/steering
    public static final int kFrontLeftSteerMotorID = 9;    // FL steering
    public static final int kFrontRightSteerMotorID = 10;  // FR steering
    public static final int kBackLeftSteerMotorID = 11;    // BL steering
    public static final int kBackRightSteerMotorID = 12;   // BR steering

    // ===== DRIVE MOTORS (Kraken X60) =====
    // Kraken X60 - full power motors for driving
    public static final int kFrontLeftDriveMotorID = 13;   // FL drive
    public static final int kFrontRightDriveMotorID = 14;  // FR drive
    public static final int kBackLeftDriveMotorID = 15;    // BL drive
    public static final int kBackRightDriveMotorID = 16;   // BR drive

    // ===== CANCODERS (Absolute Encoders) =====
    // Required for absolute steering position on startup
    public static final int kFrontLeftEncoderID = 19;      // FL CANCoder
    public static final int kFrontRightEncoderID = 20;     // FR CANCoder
    public static final int kBackLeftEncoderID = 21;       // BL CANCoder
    public static final int kBackRightEncoderID = 22;      // BR CANCoder

    // ===== ENCODER OFFSETS (TUNE THESE) =====
    // Offset in rotations to zero position (wheels pointing forward)
    // Set these after calibrating with wheels straight
    public static final double kFrontLeftEncoderOffset = 0.0;
    public static final double kFrontRightEncoderOffset = 0.0;
    public static final double kBackLeftEncoderOffset = 0.0;
    public static final double kBackRightEncoderOffset = 0.0;

    // ===== PHYSICAL DIMENSIONS (TUNE THESE) =====
    // Distance from robot center to wheel center (meters)
    // Measure carefully for accurate odometry!
    public static final double kWheelBaseMeters = 0.0;      // Front-to-back distance
    public static final double kTrackWidthMeters = 0.0;     // Left-to-right distance
    public static final double kWheelRadiusMeters = 0.0;    // Wheel radius

    // ===== GEAR RATIOS (TUNE THESE) =====
    // Depends on your swerve module type (SDS, WCP, etc.)
    public static final double kDriveGearRatio = 0.0;       // Motor rotations per wheel rotation
    public static final double kSteerGearRatio = 0.0;       // Motor rotations per module rotation

    // ===== CURRENT LIMITS =====
    public static final double kDriveCurrentLimit = 80.0;   // Amps - Kraken X60
    public static final double kSteerCurrentLimit = 40.0;   // Amps - Kraken X44

    // ===== MOTOR INVERSIONS (TUNE THESE) =====
    // Set based on your module wiring
    public static final boolean kFrontLeftDriveInverted = false;
    public static final boolean kFrontRightDriveInverted = false;
    public static final boolean kBackLeftDriveInverted = false;
    public static final boolean kBackRightDriveInverted = false;
    public static final boolean kFrontLeftSteerInverted = false;
    public static final boolean kFrontRightSteerInverted = false;
    public static final boolean kBackLeftSteerInverted = false;
    public static final boolean kBackRightSteerInverted = false;

    // ===== PID GAINS (TUNE THESE) =====
    // Drive motor velocity PID
    public static final double kDriveKp = 0.0;
    public static final double kDriveKi = 0.0;
    public static final double kDriveKd = 0.0;
    public static final double kDriveKv = 0.0;              // Feedforward
    public static final double kDriveKs = 0.0;              // Static friction

    // Steer motor position PID
    public static final double kSteerKp = 0.0;
    public static final double kSteerKi = 0.0;
    public static final double kSteerKd = 0.0;

    // ===== SPEED LIMITS (TUNE THESE) =====
    public static final double kMaxSpeedMetersPerSec = 0.0;       // Max linear speed
    public static final double kMaxAngularSpeedRadPerSec = 0.0;   // Max rotation speed
  }
}
//smooth accel code 